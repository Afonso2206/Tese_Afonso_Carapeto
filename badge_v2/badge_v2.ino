#include <Wire.h>
#include <GyverOLED.h>

GyverOLED<SSH1106_128x64> oled;

#define SLAVE_ADDRESS 0x50

//----------------------------------------QR CODE------------------------*/

#include <sstream>
#include "qrcodegen.hpp"

using std::uint8_t;
using qrcodegen::QrCode;
using qrcodegen::QrSegment;


// Function prototypes
static void doBasicDemo();
static std::string toSvgString(const QrCode &qr, int border);

/*---------------------------------------BLACKBOARD---------------------*/

struct Blackboard {
  uint8_t KeyStatus0;
  uint8_t i;
  uint8_t Array_SettingRegisters[22];
  const char* Student_Info = "BEGIN:VCARD\n"
                       "VERSION:3.0\n"
                       "FN;CHARSET=UTF-8:Afonso Santos Carapeto\n"
                       "N;CHARSET=UTF-8:Carapeto;Afonso;Santos;;\n"
                       "EMAIL;CHARSET=UTF-8;type=HOME,INTERNET:afonso.carapeto@tecnico.ulisboa.pt\n"
                       "TEL;TYPE=CELL:+351 929264325\n"
                       "NOTE;CHARSET=UTF-8:MEEC nº 93763\n"
                       "REV:2024-01-16T14:41:13.993Z\n"
                       "END:VCARD\n";
  const char* menu_items[6] = {
    "User Data",
    "Games",
    "Voltmeter",
    "I2C Explorer",
    "Focus Attention",
    "IST Info"
  };

  const char* submenu_items[6][2] = {
    {"See user data", "Show QR Code"},      // Submenu options for User Data
    {"Games 1", "Games 2"},            // Submenu options for Games
    {"Digital", "Analog"},    // Submenu options for Voltmeter
    {"I2C Explorer 1", "I2C Explorer 2"},  // Submenu options for I2C Explorer
    {"Focus Attention 1", "Focus Attention 2"},  // Submenu options for Focus Attention
    {"IST Alameda", "IST Taguspark"}       // Submenu options for IST Info
};
  
  const int menu_length = sizeof(menu_items) / sizeof(menu_items[0]);
  int current_index = 0;
  int current_submenu_index = 0;
  bool in_submenu = false;
  
  const uint8_t IST_Logo[128*8] PROGMEM  = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0x7f, 0x3f, 0x3f, 0xbf, 0xbf, 0xbf, 0xbf, 0x3f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xe0, 0xe0, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xff, 0xff, 0xf1, 0xf1, 0x01, 0x01, 0x01, 0x01, 0x01, 0xf1, 0xf1, 0xf1, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x1f, 0x7f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xf3, 0xc1, 0x81, 0x81, 0x01, 0x1f, 0x7f, 0x7f, 0x7f, 0x3f, 0x00, 0x80, 
  0x80, 0xc0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x3f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 
  0x0f, 0x1f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x3f, 0x0f, 
  0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x0f, 0x1f, 0x3f, 0x3f, 0x7f, 0x7f, 
  0xff, 0x7f, 0x7f, 0x3f, 0x3f, 0x1f, 0x0f, 0x07, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
};

Blackboard bb;

void ReadAndProcessKeyStatus();
void Print_KeyStatus(uint8_t KeyPressed);
uint8_t Read_SettingRegisters(uint8_t Register);
void Write_SettingRegisters();
void DisplayStartupSequence(); 

int main() 
{
  Wire.begin();
  DisplayStartupSequence(); // Display startup sequence before regular program
  oled.clear();
  update_display();
  
  for (bb.i = 0xB0; bb.i < 0xC6; bb.i++) {
    bb.Array_SettingRegisters[bb.i - 0xB0] = Read_SettingRegisters(bb.i);
  }
  
  Write_SettingRegisters();
  pinMode(LED_BUILTIN, OUTPUT);
  
  while (true) {
    delay(100);  
    ReadAndProcessKeyStatus();
  }

  return 0; 
}

void ReadAndProcessKeyStatus() {
  Wire.beginTransmission(SLAVE_ADDRESS); 
  Wire.write(0x08);  
  Wire.endTransmission(); 
  Wire.requestFrom(SLAVE_ADDRESS, 1); 
  while (Wire.available()) bb.KeyStatus0 = Wire.read();

  if (bb.KeyStatus0 != 0) {
    digitalWrite(LED_BUILTIN, HIGH);
    Print_KeyStatus(bb.KeyStatus0);
  } else {
    digitalWrite(LED_BUILTIN, LOW);
  }
}

void Print_KeyStatus(uint8_t KeyPressed) {
  oled.clear();
  oled.home();
  
  switch (KeyPressed) {
    case 0x01:
      oled.println("LEFT");
      break;
    case 0x02:         //Presses "UP"
      navigate_up();
      break;
    case 0x04:       //Presses "DOWN"
      navigate_down();
      break;
    case 0x08:
      oled.println("RIGHT");
      break;
    case 0x10:        //Presses "OK"
      if (!bb.in_submenu) {
        bb.in_submenu = true;
        update_display();
      } else {
        select_submenu_option();    ///////-------------------SUBSTITUIR MAIS À FRENTE COM O QUE CADA OPCAO FAZ, EXEMPLO: SE CLICA NO USER DATA MOSTRA OS DADOS----//
      }
      break;
    case 0x20:        //Presses "BACK"
      if (bb.in_submenu) {
        exit_submenu();
      }
      break;
  }
  
  oled.update();
}

uint8_t Read_SettingRegisters(uint8_t Register) {
  Wire.beginTransmission(SLAVE_ADDRESS); 
  Wire.write(Register);   
  Wire.endTransmission();
  Wire.requestFrom(SLAVE_ADDRESS, 1); 
  while (Wire.available()) return Wire.read();
  return 0;
}

void Write_SettingRegisters() {
  Wire.beginTransmission(SLAVE_ADDRESS); 
  Wire.write(0xB0);
  for (bb.i = 0; bb.i < 22; bb.i++) {
    Wire.write(bb.Array_SettingRegisters[bb.i]);
  }    
  Wire.endTransmission();
}

//------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------//

void navigate_up() {
  // Move selection up based on whether in main menu or submenu
  if (bb.in_submenu) {
    // Move selection up in the submenu
    if (bb.current_submenu_index > 0) {
      bb.current_submenu_index--;
    } else {
      // Wrap around to the bottom of the submenu if at the top
      bb.current_submenu_index = 1;
    }
  } else {
    // Move selection up in the main menu
    if (bb.current_index > 0) {
      bb.current_index--;
    } else {
      // Wrap around to the bottom of the menu if at the top
      bb.current_index = bb.menu_length - 1;
    }
  }
  update_display();
}

void navigate_down() {
  // Move selection down based on whether in main menu or submenu
  if (bb.in_submenu) {
    // Move selection down in the submenu
    if (bb.current_submenu_index < 1) {
      bb.current_submenu_index++;
    } else {
      // Wrap around to the bottom of the submenu if at the top
      bb.current_submenu_index = 0;;
    }
  } else {
    // Move selection down in the main menu
    if (bb.current_index < bb.menu_length - 1) {
      bb.current_index++;
    } else {
      // Wrap around to the top of the menu if at the bottom
      bb.current_index = 0;
    }
  }
  update_display();
}

void exit_submenu() {
  // Exit the submenu and go back to the main menu
  bb.in_submenu = false;
  update_display();
}

void select_submenu_option() {
  // Print the selected submenu option
  const char* option = bb.submenu_items[bb.current_index][bb.current_submenu_index];
  oled.clear();
  oled.home();
  oled.setScale(1);
  oled.invertText(false);
  if (option == "See user data"){
    oled.println("Afonso Carapeto");
    oled.println("IST 193763");
    oled.println("MEEC");
    oled.println("929264325");
    oled.println("afonso.carapeto");
    oled.println("@tecnico.ulisboa.pt");
  }
  else if (option == "Show QR Code"){
    displayQRCode(bb.Student_Info);
  }
  else if (option == "IST Alameda"){
    oled.println("Av. Rovisco Pais");
    oled.println("1049-001 Lisboa");
    oled.println("218417000");
  }
  else if (option == "IST Taguspark"){
    oled.println("Av. Prof. Dr. Cavaco");
    oled.println("Silva");
    oled.println("2744-016 Porto Salvo");
    oled.println("214233200");
  }
  
  /*oled.clear();
  oled.home();
  oled.setScale(1);
  oled.invertText(false); // Ensure text inversion is off
  oled.println(option);*/
  oled.update();
}

void update_display() {
  // Refresh the display based on the current menu and index
  oled.clear();
  oled.home();
  oled.setScale(1);

  if (bb.in_submenu) {
    // Display submenu options
    oled.invertText(false); // Turn off inversion before printing submenu
    oled.println(bb.menu_items[bb.current_index]);
    oled.println("");
    for (int k = 0; k < 2; k++) { // Iterate through submenu options
      if (k == bb.current_submenu_index) {
        oled.invertText(true);
      } else {
        oled.invertText(false);
      }
      oled.println(bb.submenu_items[bb.current_index][k]);
    }
  } else {
    // Display main menu
    oled.invertText(false); // Turn off inversion before printing main menu
    oled.println("Main Menu");
    oled.println("");
    for (int j = 0; j < bb.menu_length; j++) {
      if (j == bb.current_index) {
        oled.invertText(true);
      } else {
        oled.invertText(false);
      }
      oled.println(bb.menu_items[j]);
    }
  }

  oled.update();
}



void DisplayStartupSequence() {
  // Display startup sequence, e.g., displaying logo, animation, etc.
  // For example:
  oled.init();
  oled.clear();
  oled.drawBitmap(0, 0, bb.IST_Logo, 128, 64);
  oled.update();
  delay(1000); // You can adjust the delay as needed
}

void Info_IST(){
  
}

//-----------------------------------------------------------------------------------------//
//----------------------------QR CODE FUNCTIONS-------------------------------------------------------------//
//-----------------------------------------------------------------------------------------//

void displayQRCode(const char *text) {
  int scale = 2;
  const QrCode::Ecc errCorLvl = QrCode::Ecc::LOW;
  const QrCode qr = QrCode::encodeText(text, errCorLvl);

  int border = 1;
  int rectSize = 2; // Adjust this size as needed

  for (int y = -border; y < qr.getSize() + border; y++) {
    for (int x = -border; x < qr.getSize() + border; x++) {
      int xPos = translateX(x, y, border, qr.getSize());
      int yPos = translateY(x, y, border, qr.getSize());
      if (!qr.getModule(x, y)) {
        oled.dot(xPos, yPos);
      }
    }
  }
}

// Returns a string of SVG code for an image depicting the given QR Code, with the given number
// of border modules. The string always uses Unix newlines (\n), regardless of the platform.
static std::string toSvgString(const QrCode &qr, int border) {
  if (border < 0)
    throw std::domain_error("Border must be non-negative");
  if (border > INT_MAX / 2 || border * 2 > INT_MAX - qr.getSize())
    throw std::overflow_error("Border too large");
  
  std::ostringstream sb;
  sb << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
  sb << "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n";
  sb << "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ";
  sb << (qr.getSize() + border * 2) << " " << (qr.getSize() + border * 2) << "\" stroke=\"none\">\n";
  sb << "\t<rect width=\"100%\" height=\"100%\" fill=\"#FFFFFF\"/>\n";
  sb << "\t<path d=\"";
  for (int y = 0; y < qr.getSize(); y++) {
    for (int x = 0; x < qr.getSize(); x++) {
      if (qr.getModule(x, y)) {
        if (x != 0 || y != 0)
          sb << " ";
        sb << "M" << (x + border) << "," << (y + border) << "h1v1h-1z";
      }
    }
  }
  sb << "\" fill=\"#000000\"/>\n";
  sb << "</svg>\n";
  return sb.str();
}


int translateX(int x, int y, int border, int qrSize) {
  // Center the QR Code on a 128x64 display
  int displayWidth = 128;
  return (displayWidth - qrSize) / 2 + x + border;
}

int translateY(int x, int y, int border, int qrSize) {
  // Center the QR Code on a 128x64 display
  int displayHeight = 64;
  return (displayHeight - qrSize) / 2 + y + border;
}
